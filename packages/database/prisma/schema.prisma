generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

enum Role {
  CLIENT
  PROFESSIONAL
  ADMIN
}

enum UserStatus {
  PENDING
  ACTIVE
  SUSPENDED
  BANNED
}

enum ProLevel {
  BRONZE
  SILVER
  GOLD
  PLATINUM
}

enum RiskLevel {
  LOW
  MEDIUM
  HIGH
}

enum JobStatus {
  CREATED
  QUOTED
  PENDING_PAYMENT
  PAID
  PENDING_QUOTE
  QUOTE_SENT
  QUOTE_ACCEPTED
  QUOTE_REJECTED
  ASSIGNED
  PRO_ACCEPTED
  PRO_ON_WAY
  IN_PROGRESS
  PENDING_APPROVAL
  COMPLETED
  IN_GUARANTEE
  CLOSED
  CANCELLED
  DISPUTED
}

enum QuoteStatus {
  PENDING
  ACCEPTED
  REJECTED
  EXPIRED
}

model User {
  id         String     @id @default(uuid())
  email      String     @unique
  phone      String     @unique
  password   String
  name       String
  cpf        String?    @unique
  role       Role       @default(CLIENT)
  status     UserStatus @default(PENDING)
  avatar_url String?
  created_at DateTime   @default(now())
  updated_at DateTime   @updatedAt

  addresses        Address[]
  professional     Professional?
  jobs_as_client   Job[]    @relation("ClientJobs")
  jobs_as_pro      Job[]    @relation("ProJobs")
  reviews_given    Review[] @relation("ReviewsGiven")
  reviews_received Review[] @relation("ReviewsReceived")
  quotes_sent      Quote[]  @relation("ProfessionalQuotes")

  // Payment relations
  refunds_requested    Refund[]      @relation("RefundsRequested")
  refunds_approved     Refund[]      @relation("RefundsApproved")
  withdrawals_approved Withdrawal[]  @relation("WithdrawalsApproved")
  transactions         Transaction[]
  balance              Balance?

  // Chat & Notifications relations
  conversations_as_client   Conversation[] @relation("ClientConversations")
  conversations_as_pro      Conversation[] @relation("ProfessionalConversations")
  messages_sent             Message[]      @relation("MessagesSent")
  notifications             Notification[] @relation("Notifications")

  @@map("users")
}

model Professional {
  id      String @id @default(uuid())
  user_id String @unique
  user    User   @relation(fields: [user_id], references: [id], onDelete: Cascade)

  cpf_verified     Boolean @default(false)
  selfie_verified  Boolean @default(false)
  address_verified Boolean @default(false)

  level      ProLevel @default(BRONZE)
  total_jobs Int      @default(0)
  rating_avg Float    @default(0)

  pix_key        String?
  is_available   Boolean @default(true)
  work_radius_km Int     @default(20)

  specialties Specialty[]
  services    ProfessionalService[]
  withdrawals Withdrawal[]

  created_at DateTime @default(now())
  updated_at DateTime @updatedAt

  @@map("professionals")
}

model Category {
  id        String  @id @default(uuid())
  name      String
  slug      String  @unique
  icon      String?
  color     String?
  is_active Boolean @default(true)
  order     Int     @default(0)

  missions    Mission[]
  specialties Specialty[]

  created_at DateTime @default(now())

  @@map("categories")
}

model Mission {
  id          String   @id @default(uuid())
  name        String
  slug        String   @unique
  description String
  category_id String
  category    Category @relation(fields: [category_id], references: [id])

  price_min     Int // centavos
  price_max     Int // centavos
  price_default Int // centavos

  duration_min Int // minutos
  duration_max Int // minutos

  requires_photo Boolean   @default(true)
  risk_level     RiskLevel @default(LOW)
  is_active      Boolean   @default(true)

  jobs Job[]
  professional_services ProfessionalService[]

  created_at DateTime @default(now())

  @@map("missions")
}

model Specialty {
  id            String         @id @default(uuid())
  name          String
  category_id   String
  category      Category       @relation(fields: [category_id], references: [id])
  professionals Professional[]

  @@map("specialties")
}

model Address {
  id      String @id @default(uuid())
  user_id String
  user    User   @relation(fields: [user_id], references: [id], onDelete: Cascade)

  label        String?
  street       String
  number       String
  complement   String?
  neighborhood String
  city         String
  state        String  @default("RS")
  zip_code     String

  latitude  Float?
  longitude Float?

  is_default Boolean @default(false)

  jobs       Job[]
  created_at DateTime @default(now())

  @@map("addresses")
}

model Job {
  id   String @id @default(uuid())
  code String @unique

  client_id String
  client    User   @relation("ClientJobs", fields: [client_id], references: [id])

  pro_id String?
  pro    User?   @relation("ProJobs", fields: [pro_id], references: [id])

  mission_id String
  mission    Mission @relation(fields: [mission_id], references: [id])

  address_id String
  address    Address @relation(fields: [address_id], references: [id])

  status JobStatus @default(CREATED)

  diagnosis_answers Json?
  photos_before     String[]
  photos_after      String[]
  ai_diagnosis      Json?

  price_estimated  Int
  price_final      Int?
  price_additional Int?

  scheduled_date   DateTime?
  scheduled_window String?

  started_at      DateTime?
  completed_at    DateTime?
  guarantee_until DateTime?

  review Review?
  quotes Quote[]

  // Payment relations
  payment      Payment?
  transactions Transaction[]

  // Chat relation
  conversation Conversation?

  created_at DateTime @default(now())
  updated_at DateTime @updatedAt

  @@map("jobs")
}

model Review {
  id     String @id @default(uuid())
  job_id String @unique
  job    Job    @relation(fields: [job_id], references: [id])

  reviewer_id String
  reviewer    User   @relation("ReviewsGiven", fields: [reviewer_id], references: [id])

  reviewed_id String
  reviewed    User   @relation("ReviewsReceived", fields: [reviewed_id], references: [id])

  rating_overall      Int
  rating_punctuality  Int?
  rating_quality      Int?
  rating_friendliness Int?

  comment String?

  created_at DateTime @default(now())

  @@map("reviews")
}

model Quote {
  id              String      @id @default(uuid())
  job_id          String
  job             Job         @relation(fields: [job_id], references: [id], onDelete: Cascade)
  professional_id String
  professional    User        @relation("ProfessionalQuotes", fields: [professional_id], references: [id])

  amount          Int         // Valor em centavos
  notes           String?     // Observações do profissional
  available_dates String[]    // Datas disponíveis (JSON array de strings)

  status          QuoteStatus @default(PENDING)

  created_at      DateTime    @default(now())
  responded_at    DateTime?   // Quando o cliente respondeu

  @@map("quotes")
}

model ProfessionalService {
  id              String       @id @default(uuid())
  professional_id String
  professional    Professional @relation(fields: [professional_id], references: [id], onDelete: Cascade)
  mission_id      String
  mission         Mission      @relation(fields: [mission_id], references: [id])

  price_min       Int          // Preço mínimo que cobra (centavos)
  price_max       Int          // Preço máximo (centavos)
  description     String?      // Observações sobre o serviço
  is_active       Boolean      @default(true)

  created_at      DateTime     @default(now())
  updated_at      DateTime     @updatedAt

  @@unique([professional_id, mission_id])
  @@map("professional_services")
}

// ============================================
// PAYMENT SYSTEM ENUMS
// ============================================

enum PaymentStatus {
  PENDING
  PROCESSING
  COMPLETED
  FAILED
  REFUNDED
  PARTIALLY_REFUNDED
  CANCELLED
}

enum PaymentMethod {
  PIX
  CREDIT_CARD
  DEBIT_CARD
}

enum TransactionType {
  PAYMENT
  SPLIT_PROFESSIONAL
  SPLIT_PLATFORM
  REFUND
  WITHDRAWAL
  FEE
}

enum WithdrawalStatus {
  PENDING
  APPROVED
  PROCESSING
  COMPLETED
  REJECTED
  FAILED
}

enum MessageType {
  TEXT
  IMAGE
  FILE
  SYSTEM
}

enum NotificationType {
  NEW_JOB
  NEW_QUOTE
  QUOTE_ACCEPTED
  QUOTE_REJECTED
  JOB_STARTED
  JOB_COMPLETED
  PAYMENT_RECEIVED
  NEW_MESSAGE
  NEW_REVIEW
  SYSTEM
}

// ============================================
// PAYMENT SYSTEM MODELS
// ============================================

model Payment {
  id                 String        @id @default(uuid())
  job_id             String        @unique
  job                Job           @relation(fields: [job_id], references: [id], onDelete: Cascade)
  amount             Int           // centavos
  method             PaymentMethod
  status             PaymentStatus @default(PENDING)
  gateway_payment_id String?       @unique
  gateway_provider   String?
  gateway_response   Json?
  paid_at            DateTime?
  expires_at         DateTime?
  qr_code            String?
  qr_code_base64     String?
  installments       Int           @default(1)
  installment_amount Int?
  splits             PaymentSplit[]
  refunds            Refund[]
  transactions       Transaction[]
  created_at         DateTime      @default(now())
  updated_at         DateTime      @updatedAt

  @@index([job_id])
  @@index([gateway_payment_id])
  @@index([status])
  @@map("payments")
}

model PaymentSplit {
  id             String   @id @default(uuid())
  payment_id     String
  payment        Payment  @relation(fields: [payment_id], references: [id], onDelete: Cascade)
  recipient_type String   // "PROFESSIONAL" or "PLATFORM"
  recipient_id   String?
  amount         Int      // centavos
  percentage     Float
  status         String   @default("PENDING")
  held_until     DateTime?
  released_at    DateTime?
  created_at     DateTime @default(now())
  updated_at     DateTime @updatedAt

  @@index([payment_id])
  @@index([recipient_id])
  @@map("payment_splits")
}

model Refund {
  id                String   @id @default(uuid())
  payment_id        String
  payment           Payment  @relation(fields: [payment_id], references: [id], onDelete: Cascade)
  amount            Int
  reason            String
  status            String   @default("PENDING")
  gateway_refund_id String?  @unique
  gateway_response  Json?
  requested_by_id   String
  requested_by      User     @relation("RefundsRequested", fields: [requested_by_id], references: [id])
  approved_by_id    String?
  approved_by       User?    @relation("RefundsApproved", fields: [approved_by_id], references: [id])
  requested_at      DateTime @default(now())
  approved_at       DateTime?
  completed_at      DateTime?
  created_at        DateTime @default(now())
  updated_at        DateTime @updatedAt

  @@index([payment_id])
  @@map("refunds")
}

model Withdrawal {
  id                  String           @id @default(uuid())
  professional_id     String
  professional        Professional     @relation(fields: [professional_id], references: [id])
  amount              Int
  pix_key             String
  status              WithdrawalStatus @default(PENDING)
  approved_by_id      String?
  approved_by         User?            @relation("WithdrawalsApproved", fields: [approved_by_id], references: [id])
  rejection_reason    String?
  gateway_transfer_id String?          @unique
  gateway_response    Json?
  requested_at        DateTime         @default(now())
  approved_at         DateTime?
  processed_at        DateTime?
  completed_at        DateTime?
  created_at          DateTime         @default(now())
  updated_at          DateTime         @updatedAt

  @@index([professional_id])
  @@index([status])
  @@map("withdrawals")
}

model Transaction {
  id             String          @id @default(uuid())
  user_id        String
  user           User            @relation(fields: [user_id], references: [id])
  type           TransactionType
  amount         Int
  balance_before Int
  balance_after  Int
  payment_id     String?
  payment        Payment?        @relation(fields: [payment_id], references: [id])
  job_id         String?
  job            Job?            @relation(fields: [job_id], references: [id])
  description    String
  metadata       Json?
  created_at     DateTime        @default(now())

  @@index([user_id])
  @@index([type])
  @@index([created_at])
  @@map("transactions")
}

model Balance {
  id              String   @id @default(uuid())
  user_id         String   @unique
  user            User     @relation(fields: [user_id], references: [id], onDelete: Cascade)
  available       Int      @default(0)
  held            Int      @default(0)
  total_earned    Int      @default(0)
  total_withdrawn Int      @default(0)
  updated_at      DateTime @updatedAt

  @@map("balances")
}

// ============================================
// CHAT & NOTIFICATIONS SYSTEM
// ============================================

model Conversation {
  id      String @id @default(uuid())
  job_id  String @unique
  job     Job    @relation(fields: [job_id], references: [id], onDelete: Cascade)

  client_id       String
  client          User   @relation("ClientConversations", fields: [client_id], references: [id])

  professional_id String?
  professional    User?  @relation("ProfessionalConversations", fields: [professional_id], references: [id])

  last_message_at DateTime?
  last_message_preview String?

  messages Message[]

  created_at DateTime @default(now())
  updated_at DateTime @updatedAt

  @@index([client_id])
  @@index([professional_id])
  @@map("conversations")
}

model Message {
  id              String      @id @default(uuid())
  conversation_id String
  conversation    Conversation @relation(fields: [conversation_id], references: [id], onDelete: Cascade)

  sender_id String
  sender    User   @relation("MessagesSent", fields: [sender_id], references: [id])

  type    MessageType @default(TEXT)
  content String      @db.Text

  file_url  String?
  file_name String?
  file_size Int?

  read_at DateTime?
  created_at DateTime @default(now())

  @@index([conversation_id, created_at])
  @@index([sender_id])
  @@map("messages")
}

model Notification {
  id      String           @id @default(uuid())
  user_id String
  user    User             @relation("Notifications", fields: [user_id], references: [id], onDelete: Cascade)

  type    NotificationType
  title   String
  message String           @db.Text

  job_id   String?
  quote_id String?

  data Json?

  read_at    DateTime?
  clicked_at DateTime?

  created_at DateTime @default(now())

  @@index([user_id, read_at])
  @@index([user_id, created_at])
  @@map("notifications")
}
